# project02-alhanson7210
project02-alhanson7210 created by GitHub Classroom

Due Date
Due in GitHub by Monday, September 21st at 11:59 PM

Create your repo in the GitHub Classroom Assignment published in your section's Piazza 

Given
We will give a working reference implementation of the scanner and parser we have worked on in class. 

You will expand that implementation to match the EBNF given below, and provide your own bitwise operations and base conversions.

Requirements
You will use the techniques we've learned for scanning, parsing, and number manipulation to build an interpreter for a little language with the EBNF grammars given below.

Your interpreter will take an expression , a number base, and a width on the command line, and print its output to stdout like this:
```
$ ./project02 -e "10" -b 16
0x0000000A
$ ./project02 -e "10" -b 16 -w 16
0x000A
$ ./project02 -e "10" -b 2
0b00000000000000000000000000001010
$ ./project02 -e "10" -b 2 -w 4
0b1010
$ ./project02 -e "0x0A" -b 10
10
$ ./project02 -e "0x0A" -b 2 -w 8
0b00001010
```
```
$ ./project02 -e "((1 + 1) * 1)" -b 16 -w 16
0x0002
$ ./project02 -e "((1 + 1) * 1)" -b 2 -w 8
0b00000010
```
```
$ ./project02 -e "(1 << 16)" -b 10 -w 32
65536
$ ./project02 -e "(1 << 16)" -b 10 -w 16
0
$ ./project02 -e "(1 << 16)" -b 16 -w 32
0x00010000
```
```
$ ./project02 -b 10 -w 8 -e "(2 * (0b1111 & 0b1010))"
10
```
```
$ ./project02 -b 10 -w 8 -e "0b00001000"
8
$ ./project02 -b 10 -w 4 -e "0b00001000"
-8
$ ./project02 -b 10 -u -w 4 -e "0b00001000"
8
```
```
$ ./project02 -b 10 -w 4 -e "0b1100"
-4
$ ./project02 -b 10 -u -w 4 -e "0b1100"
12
```
Valid inputs for the number base are -b 2, -b 10, and -b 16

Valid inputs for the width are -w 4, -w 8, -w 16, and -w 32

Print unsigned ints with -u (this only has meaning for -b 10)

You will write the scanner and parser yourself, without using C strtok() or scanf() or compiler generators such as lex, yacc, bison, antlr, etc.

You will write the base conversion tools yourself without using C printf("%d", i) or printf("%x", i)

Scanner
As with lab02, your scanner will read the input file and create a data structure of tokens. 

The EBNF grammar for the scanner is:
```
tokenlist  ::= (token)*
token      ::= intlit | hexlit | binlit | symbol
symbol     ::= '+' | '-' | '*' | '/' | '>>' | '<<' | '~' | '&' | '|' | '^' 
intlit     ::= digit (digit)*
hexlit     ::= '0x' | hexdigit (hexdigit)*
binlit     ::= '0b' ['0', '1'] (['0', '1'])*
hexdigit   ::= 'a' | ... | 'f' | 'A' | ... | 'F' | digit
digit      ::= '0' | ... | '9'
# Ignore
whitespace ::= ' ' | '\t' (' ' | '\t')*
```
Parser
As with lab03, your parser will generate parse tree (AST) which represents the meaning of the tokens generated by the scanner.

The parser adds the following elements to the EBNF grammar:
```
program    ::= expression EOT

expression ::= operand (operator operand)*

operand    ::= intlit
              | hexlit
               | binlit
               | '-' operand
              | '~' operand
              | '(' expression ')'
```
The bitwise operators do the same thing as their counterparts in C.
```
>> right shift
>- arithmetic shift right
<< left shift
~ bitwise not
& bitwise and
| bitwise or
^ bitwise xor
```
Interpreter
Your interpreter will walk the AST depth-first, evaluating the expressions defined by the nodes, and printing the results.

You may want to store the intermediate results in a C integer, to make conversion to binary or hexadecimal easy. It's possible to use a C character string instead if you prefer, but that may be a little more work.

The width parameter controls how many bits wide the output should be. 

Grading
Grading will have two components: automated and interactive.

For interactive grading, we will schedule 1:1 meetings with the instructor or TAs using a Google Sheet published in your section's Piazza. 

You should be prepared to share your screen and answer questions about your design and implementation

For automated grading, we will use the maketest tool to grade correctness of your project. You can run it yourself on your local repository to see how your code scores. Instructions are in the README.

Your project will be generated by a Makefile, and the executable will be called project02
